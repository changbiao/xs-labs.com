C - const and static keywords

Published on: Jul 29, 2011 @ 1:30

Ok, once and for all, I'll try to clarify to meaning of the 'const' and 'static' keywords in C (it applies to Objective-C and C++ too).

I'm just tired of questions about this on StackOverflow.

Objective-C programmers usually don't think about C code while coding. I personally think this is a big mistake (it can sometimes apply to C++ programmers too).

Objective-C is just a layer over C. So in order to be a good Objective-C programmer, you <strong>HAVE</strong> to know at least a few things about the C language.

I don't know why C has such a bad reputation for Objective-C coders, especially on iOS. And it's very surprising to see the lack of knowledge of some Objective-C developers.

So once and for all:

If you want to code in Objective-C, learn at least the following C topics:

<ul>
	<li>Language keywords and their meanings</li>
	<li>Pointers and pointer arithmetic</li>
	<li>C standard library</li>
</ul>

Those are the (very) basics.

Objective-C is a very nice object-oriented language, with amazing runtime capabilities. That's true.
But it doesn't mean you can bypass completely the C language.
A lot of time, you'll save a lot of processor time and memory, just by knowing a few things about the C language, rather than relying on the apparent simplicity of the Objective-C language.

But that's a different story. Now back on our keywords...

<h3>const</h3>

First of all, the <code>const</code> keyword.

Ok, it means 'constant'... So:

<pre class="code-block language-c">
const int x = 42;
</pre>

declares a constant integer variable. It means its value can't be modified. Its value is initially assigned to 42.
If you try to change its value later, the compiler will issue a warning, or an error, depending on your compiler settings.
So the following statement is invalid:

<pre class="code-block language-c">
const int x = 42;
x           = 43;
</pre>

That's pretty easy to understand.
The problem comes with pointers.

Let's take a look at the following code:

<pre class="code-block language-c">
char * str = "hello, world";
</pre>

It declares a <code>char</code> pointer. Ok… But then what about this:

<pre class="code-block language-c">
char * const str = "hello, world";
</pre>

or

<pre class="code-block language-c">
const char * str = "hello, world";
</pre>

Now read carefully.
The first one declares a constant pointer to a char.

It means the the characters of the string can be modified, but not the pointer value.
So the variable <code>str</code> cannot be assigned to another pointer.

For instance, this is invalid:

<pre class="code-block language-c">
char * hello     = "hello, universe";
char * const str = "hello, world";
str              = hello;
</pre>

as your a modifying the pointer value (not the string value).

This is valid:

<pre class="code-block language-c">
char * const str = strdup( "hello, world" );
str[ 0 ]         = 'a';
</pre>

The <code>str</code> variable will then contain <code>aello, world</code>. Remember: the pointer can't be modified, the value that is pointed can be.

It's the exact opposite with the following notation:

<pre class="code-block language-c">
const char * str = "hello, world";
</pre>

Here, you can assign the pointer to another variable, but you can't change the value.

The <code>const</code> keyword is contextual, in a way, when using pointers. It can apply to the pointer itself, or to the value pointed.

So, in order to resume:

<pre class="code-block language-c">
const int * x;
</pre>

A modifiable pointer to a constant integer.

<pre class="code-block language-c">
int * const x;
</pre>

A constant pointer to an modifiable integer.

<pre class="code-block language-c">
const int * const x;
</pre>

A constant pointer to a constant integer.

<h3>static</h3>

The static keyword can have two meanings.

First of all, it can be declared inside a function.
Let's take a look at this example:

<pre class="code-block language-c">
#include &lt;stdio.h&gt;

void foo( void );
void bar( void );

void foo( void )
{
    int x = 0;
    
    printf( "X - foo: %i\n", x );
    
    x++;
}

void bar( void )
{
    static int x = 0;
    
    printf( "X - bar: %i\n", x );
    
    x++;
}

int main( void )
{
    foo();
    foo();
    foo();
    bar();
    bar();
    bar();
    
    return 0;
}
</pre>

The output will be:

<pre class="code-block nohighlight">
X - foo: 0
X - foo: 0
X - foo: 0
X - bar: 0
X - bar: 1
X - bar: 2
</pre>

Because a simple local variable, as in the <code>foo</code> function, only exists when the function is called. It's destroyed (to be simple) when the function exits.

So for the <code>foo</code> function, the variable is created each time the function is called, with a value of <code>0</code>. The value is printed, then incremented.
The function then exit, and the variable is destroyed.

But in the <code>bar</code> function, the variable is declared as static. It means the value will persist across function calls.
It's initialized the first time the function is called, but only at that time. Once it has been initialized, it just exist, so its value will be taken for the next function calls.

Now the <code>static</code> keyword as a completely different meaning when used in a variable declared outside of a function (in the global scope).

It means that the variable will be «file scoped». In other words, the variable, which is global, will be accessible only from the scope of the file which declared it. It won't be accessible from other files.

It's just a way to create global private variable.

For instance, imagine a file called <code>foo.c</code>:

<pre class="code-block language-c">
int        x = 42;
static int y = 42;
</pre>

From a <code>bar.c</code> file, you'll be able to access the <code>x</code> symbol, if both files are linked together. But you won't be able to access the <code>y</code> symbol, as it's decaled as <code>static</code>.
It means that the symbol for the <code>y</code> variable won't be exported by the linker, when the symbol for the <code>x</code> variable will be.

In other words, you'll be able to access the <code>y</code> global variable only from function declared in the <code>foo.c</code> file. The <code>x</code> variable will be also accessible from other files.

Of course,  the <code>static</code> keyword can be combined with <code>const</code>.
For instance:

<pre class="code-block language-c">
static const int * const y;
</pre>

A constant pointer to a constant integer, that will be accessible only from the file which declared it.